(*
  Verificación Formal - Unam 2020-2
  Ciro Iván García López 
  Proyecto 1. Session Type Systems Verification
*)
From Coq Require Import Bool.Bool.
From Coq Require Import Arith.PeanoNat.
From Coq Require Import Ensembles.
From Coq Require Import Finite_sets.
From Coq Require Import Finite_sets_facts.
From PROYI Require Import  Defs_Process.
From Coq Require Import Lia.

Ltac inversions H := inversion H; subst.


Lemma FVars_Name_Finite :
forall (x : Name),
Finite _ (FVars_Name x).
Proof.
  destruct x.
  + simpl. apply Singleton_is_finite.
  + simpl. constructor.
Qed.

Lemma FVars_Finite :
forall (P : Prepro),
Finite _ (FVars P).
Proof.
  induction P.
  + simpl.
    constructor.
  + simpl. apply Union_preserves_Finite; apply FVars_Name_Finite.
  + simpl. apply Union_preserves_Finite; auto.
  + simpl. apply Union_preserves_Finite; try apply Union_preserves_Finite; try apply FVars_Name_Finite; auto.
  + simpl. apply FVars_Name_Finite.
  + simpl. apply Union_preserves_Finite; try apply Union_preserves_Finite; try apply FVars_Name_Finite; auto.
  + auto.
  + simpl. apply Union_preserves_Finite; try apply Union_preserves_Finite; try apply FVars_Name_Finite; auto.
  + simpl. apply Union_preserves_Finite; try apply Union_preserves_Finite; try apply FVars_Name_Finite; auto.
Qed.

Lemma No_Union_No_Each : 
forall (x : nat)( X Y : FVarsE ),
~(x ∈ (X ∪ Y)) -> ~(x ∈ X) /\ ~(x ∈ Y).
Proof.
Admitted.


Lemma FVars_Name_No_Close :
forall (z k : nat)(x : Name),
~ (z ∈ FVars_Name x) -> (Close_Name k z x = x).
Proof.
  unfold not.
  intros.
  destruct x.
  + destruct (bool_dec (x =? z) true).
    - simpl in H. apply Nat.eqb_eq in e.
      rewrite e in H.
      assert ( HB : z ∈ Singleton nat z).
      { unfold In. constructor. }
      contradiction.
    - simpl. apply not_true_iff_false in n.
      rewrite n. auto.
  + auto.
Qed.

Lemma Close_NoFVar_Eq :
forall ( P : Prepro )(z k: nat),
~ ( z ∈ (FVars P) ) -> ( Close_Rec k z P ) = P.
Proof.
  unfold Close.
  induction P; intros.
  + auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite FVars_Name_No_Close; auto.
    rewrite FVars_Name_No_Close; auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite IHP1; auto.
    rewrite IHP2; auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [H HC].
    simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite IHP; auto.
    rewrite FVars_Name_No_Close; auto.
    rewrite FVars_Name_No_Close; auto.
  + simpl in H.
    simpl.
    rewrite FVars_Name_No_Close; auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite IHP; auto.
    rewrite FVars_Name_No_Close; auto.
  + simpl in H.
    simpl.
    rewrite IHP; auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite FVars_Name_No_Close; auto.
    rewrite IHP; auto.
  + simpl in H.
    apply No_Union_No_Each in H.
    destruct H as [HA HB].
    simpl.
    rewrite FVars_Name_No_Close; auto.
    rewrite IHP; auto.
Qed.

Lemma Body_Process_Equivalence :
forall (P : Prepro),
Body P <-> Process (ν P).
Proof.
  split.
  + intros.
    constructor. inversion H. auto.
  + intros.
    inversion H. constructor. auto.
Qed.

Lemma Process_Name_Atzero :
forall ( x : Name ),
Process_Name_At 0 x -> (exists (x0 : nat), x = FName x0).
Proof.
  intros.
  destruct x.
  + exists x; auto.
  + inversions H.
    lia.
Qed.


Lemma Open_Body_Eq :
forall (P : Prepro),
Body P -> (forall (x k : nat), {(S k) ~> x} P = P ).
Proof.
Admitted.

Lemma Open_Process_Eq :
forall (P : Prepro),
Process P -> (forall (x k: nat), {k ~> x} P = P).
Proof.
  intros P H.
  induction H; intros.
  + auto.
  + inversions H.
    inversions H0.
    auto.
  + simpl.
    rewrite IHProcess1.
    rewrite IHProcess2.
    auto.
  + inversions H.
    inversions H0.
    simpl.
    rewrite IHProcess.
    auto.
  + inversions H.
    auto.
  + inversions H.
    simpl.
    rewrite IHProcess.
    auto.
  + simpl.
    rewrite (Open_Body_Eq P); try constructor; auto.
  + inversions H.
    simpl.
    rewrite (Open_Body_Eq P); try constructor; auto.
  + inversions H.
    simpl.
    rewrite (Open_Body_Eq P); try constructor; auto.
Qed.


Lemma All_Process_Body :
forall (P : Prepro),
Process P -> Body P.
Proof.
  intros.
  constructor.
  intros.
  specialize (Open_Process_Eq P) as HP.
  apply HP.
  exists (FVars P).
  intros.
  split.
  + apply FVars_Finite.
  + intros.
    specialize (HP H x 0).
    rewrite HP; auto.
Qed.


Theorem Congruence_WD :
forall P Q : Prepro, 
(P === Q) -> Process(P)  -> Process(Q).
Proof.
  intros.
  inversions H; inversions H0; auto.
  constructor.
  intros.
  simpl.
  inversions H6.
  destruct H4 as [L H4].
  exists L.
  intros.
  destruct H4.
  constructor; auto.
  intros.
  constructor.
  + specialize (Open_Process_Eq P0) as HP.
    specialize (HP H1 x 0).
    rewrite HP.
    auto.
  + apply H4.
    auto.
Qed.



(*
Resultado fundamental para la representación LNR, al hacer una redución de un proceso se obtiene un proceso.
*)
Theorem ProcessReduction_WD : 
forall P Q : Prepro, 
(P --> Q) -> Process(P)  -> Process(Q).
Proof.
  intros.
  induction H.
  + constructor; auto.
    inversions H1.
    destruct H3 as [L H3].
    destruct H3.
    admit.
  + inversions H0.
    inversions H5.
    inversions H6.
    constructor; auto.
    constructor; auto.
  + inversions H1; auto.
  + admit.
  + inversions H0.
    constructor; auto.
  + admit.
  + apply IHReduction in H.
    specialize (Congruence_WD Q' Q) as HQ.
    specialize (HQ H2 H).
    auto.
Admitted.


(*
Siempre que se hace una sustitución sobre nombres solo se pueden obtener dos resultados, se remplaza o queda igual.
*)
Lemma Subst_Name_Output :
forall ( x y : nat )( z : Name ),
Process_Name z -> ((Subst_Name x y z = (FName y)) \/ (Subst_Name x y z = z)).
Proof.
  intros.
  inversions H.
  simpl. 
  destruct (bool_dec (x0 =? x) true).
  + rewrite e. auto.
  + apply not_true_iff_false in n.
    rewrite n. auto.
Qed.


Lemma Subst_Name_Process :
forall (P : Prepro)(x y : nat),
Process P -> Process ({y \ x} P).
Proof.
  intros.
  induction H.
  + auto.
  + simpl.
    specialize (Subst_Name_Output x y x0) as HA.
    specialize (Subst_Name_Output x y y0) as HB.
    destruct HA;
      destruct HB;
        try rewrite H1;
        try rewrite H2;
        try constructor; try constructor; auto.
  + simpl.
    constructor; auto.
  + simpl.
    specialize (Subst_Name_Output x y x0) as HA.
    specialize (Subst_Name_Output x y y0) as HB.
    destruct HA;
      destruct HB;
        try rewrite H2;
        try rewrite H3;
        try constructor; try constructor; auto.
  + simpl.
    specialize (Subst_Name_Output x y x0) as HA.
    destruct HA; 
      try rewrite H0;
      try constructor; try constructor; auto.
  + simpl.
    specialize (Subst_Name_Output x y x0) as HA.
    destruct HA; 
      try rewrite H1;
      try constructor; try constructor; auto.
  + simpl.
    constructor.
    intro.
    admit.
  + simpl. 
    constructor.
    - admit.
    - intros.
      
Admitted.



Lemma Well_Open_Subst :
forall ( P : Prepro )( x y z: nat),
Well_Open ({y \ x} P) z -> exists (w : nat), Well_Open P w.
Proof.
  intros.
  inversions H.
  destruct H0 as [A H0].
  constructor.
  exists (A ∪ Singleton nat x).
Admitted.



